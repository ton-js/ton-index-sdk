{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/to-no-case@1.0.2/node_modules/to-no-case/index.js", "../../../node_modules/.pnpm/to-space-case@1.0.0/node_modules/to-space-case/index.js", "../../../node_modules/.pnpm/to-snake-case@1.0.0/node_modules/to-snake-case/index.js", "../src/errors/rate-limit.error.ts", "../src/common/network.ts", "../src/common/api-endpoints.ts", "../src/errors/options-error.error.ts", "../src/errors/http-validation.error.ts", "../src/common/normalize-base-url.ts", "../src/common/snake-case.ts", "../src/ton-index-client/request-params.ts", "../src/ton-index-client/user-agent.ts", "../src/ton-index-client/ton-index-client.ts", "../src/common/as-array.ts", "../src/http-client/http-utils.ts", "../src/http-client/fetch-http-client.ts", "../src/model/block.ts", "../src/model/message.ts", "../src/common/bigint.ts", "../src/model/transaction.ts", "../src/methods/common/make-request.ts", "../src/common/timestamp.ts", "../src/methods/get-active-accounts-count-in-period.ts", "../src/methods/get-block-by-transaction.ts", "../src/methods/get-blocks-by-unix-time.ts", "../src/methods/get-chain-last-transactions.ts", "../src/methods/get-destination-transaction-by-message.ts", "../src/common/hash.ts", "../src/methods/get-in-message-by-tx-id.ts", "../src/methods/get-messages-by-hash.ts", "../src/methods/get-out-messages-by-tx-id.ts", "../src/methods/get-source-transaction-by-message.ts", "../src/methods/get-transaction-by-hash.ts", "../src/methods/get-transactions-by-in-message-hash.ts", "../src/methods/get-transactions-by-address.ts", "../src/methods/get-transactions-by-masterchain-seqno.ts", "../src/methods/get-transactions-in-block.ts", "../src/methods/lookup-masterchain-block.ts", "../src/common/workchain.ts", "../src/common/sort.ts"],
  "sourcesContent": ["\n/**\n * Export.\n */\n\nmodule.exports = toNoCase\n\n/**\n * Test whether a string is camel-case.\n */\n\nvar hasSpace = /\\s/\nvar hasSeparator = /(_|-|\\.|:)/\nvar hasCamel = /([a-z][A-Z]|[A-Z][a-z])/\n\n/**\n * Remove any starting case from a `string`, like camel or snake, but keep\n * spaces and punctuation that may be important otherwise.\n *\n * @param {String} string\n * @return {String}\n */\n\nfunction toNoCase(string) {\n  if (hasSpace.test(string)) return string.toLowerCase()\n  if (hasSeparator.test(string)) return (unseparate(string) || string).toLowerCase()\n  if (hasCamel.test(string)) return uncamelize(string).toLowerCase()\n  return string.toLowerCase()\n}\n\n/**\n * Separator splitter.\n */\n\nvar separatorSplitter = /[\\W_]+(.|$)/g\n\n/**\n * Un-separate a `string`.\n *\n * @param {String} string\n * @return {String}\n */\n\nfunction unseparate(string) {\n  return string.replace(separatorSplitter, function (m, next) {\n    return next ? ' ' + next : ''\n  })\n}\n\n/**\n * Camelcase splitter.\n */\n\nvar camelSplitter = /(.)([A-Z]+)/g\n\n/**\n * Un-camelcase a `string`.\n *\n * @param {String} string\n * @return {String}\n */\n\nfunction uncamelize(string) {\n  return string.replace(camelSplitter, function (m, previous, uppers) {\n    return previous + ' ' + uppers.toLowerCase().split('').join(' ')\n  })\n}\n", "\nvar clean = require('to-no-case')\n\n/**\n * Export.\n */\n\nmodule.exports = toSpaceCase\n\n/**\n * Convert a `string` to space case.\n *\n * @param {String} string\n * @return {String}\n */\n\nfunction toSpaceCase(string) {\n  return clean(string).replace(/[\\W_]+(.|$)/g, function (matches, match) {\n    return match ? ' ' + match : ''\n  }).trim()\n}\n", "\nvar toSpace = require('to-space-case')\n\n/**\n * Export.\n */\n\nmodule.exports = toSnakeCase\n\n/**\n * Convert a `string` to snake case.\n *\n * @param {String} string\n * @return {String}\n */\n\nfunction toSnakeCase(string) {\n  return toSpace(string).replace(/\\s/g, '_')\n}\n", "\nexport class RateLimitError extends Error {\n\n  constructor() {\n    super(\n      'API rate limit exceeded, please use the API key ' +\n      'or decrease the number of requests'\n    );\n  }\n\n}\n", "\nimport type { Values } from '../types/values.js';\n\n\nexport const Network = {\n  Mainnet: 'mainnet',\n  Testnet: 'testnet',\n\n} as const;\n\nexport type NetworkType = (\n  | Values<typeof Network>\n);\n", "\nimport type { NetworkType } from './network.js';\nimport { Network } from './network.js';\n\n\nexport const apiEndpoints: Record<NetworkType, string> = {\n  [Network.Mainnet]: 'https://toncenter.com/api/index/',\n  [Network.Testnet]: 'https://testnet.toncenter.com/api/index/',\n};\n", "\nexport class OptionsError extends Error {\n\n  constructor(message?: string) {\n    super(message ?? 'Incorrect options provided');\n  }\n\n}\n", "\nimport type { ValidationErrorResponse } from '../model/validation-error.js';\n\n\nexport class HttpValidationError extends Error {\n\n  constructor(errors?: ValidationErrorResponse[]) {\n\n    if (errors) {\n      super(\n        // Building a single message from multiple errors\n        errors.map(error =>\n          `${error.type} at ${error.loc.join('.')} - ${error.msg}`\n        ).join('\\n')\n      );\n\n    } else {\n      super('API request validation error');\n\n    }\n\n  }\n\n}\n", "\nimport type { Maybe } from '../types/maybe.js';\n\n\nexport function normalizeBaseUrl(\n  baseUrl?: string\n\n): Maybe<string> {\n\n  baseUrl = (baseUrl || '').trim();\n\n  if (!baseUrl) {\n    return undefined;\n  }\n\n  if (!baseUrl.endsWith('/')) {\n    return `${baseUrl}/`;\n  }\n\n  return baseUrl;\n\n}\n", "\n/**\n * Using \"to-snake-case\" instead of lodash because it\n * provides a minimal implementation suitable for our needs.\n */\nimport snakeCase from 'to-snake-case';\n\nexport { snakeCase };\n", "\nimport { snakeCase } from '../common/snake-case';\n\n\nexport type RequestParams = Record<string, any>;\nexport type QueryParams = Record<string, string>;\n\n\nexport function prepareRequestQuery(\n  params: RequestParams\n\n): QueryParams {\n\n  return Object.fromEntries(\n    Object.entries(params)\n      .filter(([_, value]) => value !== undefined)\n      .map(([key, value]) => [\n        snakeCase(key),\n        ((typeof value?.toString === 'function')\n          ? value.toString()\n          : String(value)\n        ),\n      ])\n  );\n\n}\n", "\n/**\n * These values are getting injected during the build.\n */\ndeclare global {\n  const PACKAGE_NAME: string;\n  const PACKAGE_VERSION: string;\n}\n\nexport const userAgent = (\n  PACKAGE_NAME + '/' +\n  PACKAGE_VERSION\n);\n", "\nimport type { NetworkType } from '../common/network.js';\nimport type { HttpClient, RequestHeaders } from '../http-client/http-client.js';\nimport type { HttpValidationErrorResponse } from '../model/http-validation-error.js';\nimport type { Maybe } from '../types/maybe.js';\nimport { RateLimitError } from '../errors/rate-limit.error.js';\nimport { apiEndpoints } from '../common/api-endpoints.js';\nimport { Network } from '../common/network.js';\nimport { OptionsError } from '../errors/options-error.error.js';\nimport { HttpValidationError } from '../errors/http-validation.error.js';\nimport { normalizeBaseUrl } from '../common/normalize-base-url.js';\nimport { prepareRequestQuery, RequestParams } from './request-params';\nimport { userAgent } from './user-agent.js';\n\n\nexport type TonIndexClientOptions = (EndpointOptions & {\n  httpClient: HttpClient;\n  apiKey?: Maybe<string>;\n  debug?: boolean;\n});\n\nexport type EndpointOptions = ({\n  network?: NetworkType;\n  endpoint?: never;\n} | {\n  network?: never;\n  endpoint?: string;\n});\n\nexport interface RequestOptions {\n\n  /**\n   * Method's URL.\n   */\n  url: string;\n\n  /**\n   * Request parameters.\n   */\n  params: RequestParams;\n\n  /**\n   * Request timeout in milliseconds.\n   */\n  timeout?: Maybe<number>;\n\n}\n\n\nexport class TonIndexClient {\n\n  readonly #httpClient: HttpClient;\n\n  readonly #baseUrl: string;\n\n  readonly #apiKey?: Maybe<string>;\n\n  readonly #debug: boolean;\n\n\n  constructor(options: TonIndexClientOptions) {\n\n    this.#httpClient = options.httpClient;\n\n    this.#baseUrl = this.determineBaseUrl(options);\n\n    this.#apiKey = ((\n      (options.apiKey ? options.apiKey.trim() : undefined)\n    ) || undefined);\n\n    this.#debug = (options.debug ?? false);\n\n  }\n\n  public async request<\n    ResultType = any\n  >(\n    options: RequestOptions\n\n  ): Promise<ResultType> {\n\n    const url = (new URL(options.url, this.#baseUrl)\n      .toString()\n    );\n\n    // Casting all parameter keys to the snake case\n    const query = prepareRequestQuery(options.params);\n\n    const headers: RequestHeaders = {\n\n      'User-Agent': userAgent,\n\n      // @todo implement this header,\n      //       we can't use it for now due to\n      //       the server CORS settings\n      //\n      // 'X-Client-Version': userAgent,\n      //\n\n    };\n\n    if (this.#apiKey) {\n      headers['X-API-Key'] = this.#apiKey;\n    }\n\n    if (this.#debug) {\n      console.debug(\n        `URL: ${url}\\n` +\n        `Query: ${JSON.stringify(query, null, 4)}\\n` +\n        `Headers: ${JSON.stringify(headers, null, 4)}`\n      );\n    }\n\n    const response = (await this.#httpClient\n      .sendRequest<ResultType>({\n        url,\n        method: 'GET',\n        query,\n        headers,\n        timeout: options.timeout,\n      })\n    );\n\n    switch (response.status) {\n      case 200: {\n        break;\n      }\n      case 422: {\n        throw new HttpValidationError(\n          (response.payload as unknown as HttpValidationErrorResponse)\n            .detail\n        );\n      }\n      case 429: {\n        throw new RateLimitError();\n      }\n      default: {\n        const message = (response.payload as any)?.['error'];\n        throw new Error(message || `Unknown API request error`);\n      }\n    }\n\n    return response.payload;\n\n  }\n\n\n  private determineBaseUrl(\n    options: TonIndexClientOptions\n\n  ): string {\n\n    if (options.network && options.endpoint) {\n      throw new OptionsError(\n        `You can't specify both \"network\" and \"endpoint\" options, ` +\n        `use only one of them`\n      );\n    }\n\n    if (options.endpoint) {\n      let baseUrl = normalizeBaseUrl(options.endpoint);\n      if (!baseUrl) {\n        throw new OptionsError(`Incorrect endpoint URL specified`);\n      }\n      return baseUrl;\n    }\n\n    const network = (options.network ?? Network.Mainnet);\n\n    if (!apiEndpoints[network]) {\n      throw new OptionsError(\n        `Unknown network specified: ${network}`\n      );\n    }\n\n    return apiEndpoints[network];\n\n  }\n\n}\n", "\nexport function asArray<Type = any>(\n  valueOrValues: (Type | Type[])\n\n): Type[] {\n\n  return (Array.isArray(valueOrValues)\n    ? valueOrValues\n    : [valueOrValues]\n  );\n\n}\n", "\nimport type { Maybe } from '../types/maybe.js';\nimport type { RequestHeaders } from './http-client.js';\nimport { asArray } from '../common/as-array.js';\n\n\nexport async function parseResponseBody<BodyType>(\n  response: Response\n\n): Promise<BodyType> {\n\n  const contentType = (response.headers\n    .get('content-type')\n  );\n\n  const isJson = (contentType\n    ?.startsWith('application/json')\n  );\n\n  const isText = (contentType\n    ?.startsWith('text/')\n  );\n\n  return (\n    isJson ? await response.json() :\n      isText ? await response.text() :\n        undefined\n  );\n\n}\n\nexport function createHeaders(\n  headers: Maybe<RequestHeaders> = {}\n\n): Headers {\n\n  const $headers = new Headers();\n\n  for (const entry of Object.entries(headers)) {\n\n    const [name, valueOrValues] = entry;\n\n    for (let value of asArray(valueOrValues)) {\n      value = value.trim();\n      if (value) {\n        $headers.append(name, value);\n      }\n    }\n\n  }\n\n  return $headers;\n\n}\n", "\nimport type { Maybe } from '../types/maybe.js';\n\nimport type {\n  HttpClient,\n  HttpRequest,\n  HttpResponse,\n\n} from './http-client.js';\n\nimport { createHeaders, parseResponseBody } from './http-utils.js';\n\n\nexport interface FetchHttpClientOptions {\n\n  /**\n   * Request timeout in milliseconds.\n   */\n  timeout?: Maybe<number>;\n\n}\n\n\nexport class FetchHttpClient implements HttpClient {\n\n  private readonly options: {\n    timeout?: Maybe<number>;\n  };\n\n\n  constructor(options?: FetchHttpClientOptions) {\n\n    this.options = {\n      timeout: (options?.timeout || undefined),\n    };\n\n    if (\n      typeof fetch === 'undefined' ||\n      typeof Headers === 'undefined'\n    ) {\n      throw new Error(\n        `Fetch API is not found, you will need to ` +\n        `install a polyfill, please see the docs`\n      );\n    }\n\n  }\n\n\n  public async sendRequest<ResponsePayloadType>(\n    request: HttpRequest\n\n  ): Promise<HttpResponse<ResponsePayloadType>> {\n\n    const headers = createHeaders(request.headers);\n\n    headers.set('Content-Type', 'application/json');\n\n    const url = this.prepareUrl(request);\n\n    const requestOptions: RequestInit = {\n      method: (request.method?.toUpperCase() || 'GET'),\n      headers,\n      redirect: 'error',\n    };\n\n    const timeout = (\n      this.addTimeout(request, requestOptions)\n    );\n\n    let response: Response;\n\n    try {\n      response = await fetch(url, requestOptions);\n\n    } catch (error: any) {\n      if (\n        error?.type === 'aborted' ||\n        error?.name === 'AbortError'\n      ) {\n        throw new Error(\n          `HTTP request timed-out (timeout setting)`\n        );\n      } else {\n        throw error;\n      }\n\n    } finally {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n    }\n\n    return {\n      status: response.status,\n      payload: await parseResponseBody(response),\n    };\n\n  }\n\n\n  private prepareUrl(request: HttpRequest): string {\n\n    if (!request.query) {\n      return request.url;\n    }\n\n    // Adding query parameters to the URL\n    // -----\n\n    const urlObject = new URL(request.url);\n\n    for (const [key, value] of Object.entries(request.query)) {\n      urlObject.searchParams.set(key, value);\n    }\n\n    return urlObject.toString();\n\n  }\n\n  private determineTimeout(\n    request: HttpRequest\n\n  ): Maybe<number> {\n\n    const timeout = (\n      request.timeout ||\n      this.options.timeout ||\n      undefined\n    );\n\n    if (\n      (timeout !== undefined) &&\n      (typeof AbortController === 'undefined')\n    ) {\n      throw new Error(\n        `AbortController is not found, ` +\n        `please install the polyfill or ` +\n        `disable the timeout option`\n      );\n\n    }\n\n    return timeout;\n\n  }\n\n  private addTimeout(\n    request: HttpRequest,\n    requestOptions: RequestInit\n\n  ): any {\n\n    const timeout = this.determineTimeout(request);\n\n    if (timeout === undefined) {\n      return;\n    }\n\n    const abortController = new AbortController();\n    requestOptions.signal = abortController.signal;\n\n    return (\n      setTimeout(\n        () => abortController.abort(),\n        timeout\n      )\n    );\n\n  }\n\n}\n", "\nimport type { WorkchainType } from '../common/workchain.js';\n\n\n/**\n * @internal\n */\nexport interface BlockResponse {\n\n  workchain: WorkchainType;\n\n  shard: string;\n\n  seqno: number;\n\n  root_hash: string;\n\n  file_hash: string;\n\n  gen_utime: number;\n\n  start_lt: number;\n\n  end_lt: number;\n\n}\n\n\nexport class Block {\n\n  public workchain: WorkchainType;\n\n  public shard: string;\n\n  public seqno: number;\n\n  public rootHash: string;\n\n  public fileHash: string;\n\n  public genUtime: Date;\n\n  public startLt: number;\n\n  public endLt: number;\n\n\n  public constructor(response: BlockResponse) {\n\n    this.workchain = response.workchain;\n    this.shard = response.shard;\n    this.seqno = response.seqno;\n    this.rootHash = response.root_hash;\n    this.fileHash = response.file_hash;\n    this.genUtime = new Date(response.gen_utime * 1_000);\n    this.startLt = response.start_lt;\n    this.endLt = response.end_lt;\n\n  }\n\n}\n\nexport function parseBlockResponse(\n  response: BlockResponse\n\n): Block {\n\n  return new Block(response);\n\n}\n\nexport function parseBlocksListResponse(\n  response: BlockResponse[]\n\n): Block[] {\n\n  return response.map(block => new Block(block));\n\n}\n", "\nimport type { Maybe } from '../types/maybe.js';\n\n\n/**\n * @internal\n */\nexport interface MessageResponse {\n\n  /**\n   * Source.\n   */\n  source: string;\n\n  /**\n   * Destination.\n   */\n  destination: string;\n\n  /**\n   * Value.\n   */\n  value: number;\n\n  /**\n   * Fwd Fee.\n   */\n  fwd_fee: number;\n\n  /**\n   * Ihr Fee.\n   */\n  ihr_fee: number;\n\n  /**\n   * Created Lt.\n   */\n  created_lt: number;\n\n  /**\n   * Op.\n   */\n  op?: Maybe<number>;\n\n  /**\n   * Comment.\n   */\n  comment?: Maybe<string>;\n\n  /**\n   * Hash.\n   */\n  hash: string;\n\n  /**\n   * Body Hash.\n   */\n  body_hash: string;\n\n  /**\n   * Body.\n   */\n  body?: Maybe<string>;\n\n}\n\n\nexport class Message {\n\n  /**\n   * Source.\n   */\n  public source: string;\n\n  /**\n   * Destination.\n   */\n  public destination: string;\n\n  /**\n   * Value.\n   */\n  public value: bigint;\n\n  /**\n   * Fwd Fee.\n   */\n  public fwdFee: bigint;\n\n  /**\n   * Ihr Fee.\n   */\n  public ihrFee: bigint;\n\n  /**\n   * Created Lt.\n   */\n  public createdLt: number;\n\n  /**\n   * Op.\n   */\n  public op?: Maybe<number>;\n\n  /**\n   * Comment.\n   */\n  public comment?: Maybe<string>;\n\n  /**\n   * Hash.\n   */\n  public hash: string;\n\n  /**\n   * Body Hash.\n   */\n  public bodyHash: string;\n\n  /**\n   * Body.\n   */\n  public body?: Maybe<string>;\n\n\n  constructor(response: MessageResponse) {\n\n    this.source = response.source;\n    this.destination = response.destination;\n    this.value = BigInt(response.value);\n    this.fwdFee = BigInt(response.fwd_fee);\n    this.ihrFee = BigInt(response.ihr_fee);\n    this.createdLt = response.created_lt;\n    this.op = response.op;\n    this.comment = response.comment;\n    this.hash = response.hash;\n    this.bodyHash = response.body_hash;\n    this.body = response.body;\n\n  }\n\n}\n\n\nexport function parseMessageResponse(\n  response: MessageResponse\n\n): Message {\n\n  return new Message(response);\n\n}\n\nexport function parseMessageListResponse(\n  response: MessageResponse[]\n\n): Message[] {\n\n  return response.map(\n    message => new Message(message)\n  );\n\n}\n", "\nimport type { Maybe } from '../types/maybe';\n\n\nexport type MaybeBigInt = Maybe<bigint>;\n\n\nexport function maybeBigInt(\n  value: Maybe<number | string>\n\n): MaybeBigInt {\n\n  if (!value && value !== 0) {\n    return undefined;\n  }\n\n  return BigInt(value);\n\n}\n", "\nimport type { Maybe } from '../types/maybe.js';\nimport type { MaybeBigInt } from '../common/bigint';\nimport { maybeBigInt } from '../common/bigint';\nimport { Message, MessageResponse } from './message.js';\n\n\n/**\n * @internal\n */\nexport interface TransactionResponse {\n\n  /**\n   * Account.\n   */\n  account: string;\n\n  /**\n   * Lt.\n   */\n  lt: number;\n\n  /**\n   * Hash.\n   */\n  hash: string;\n\n  /**\n   * Utime.\n   */\n  utime: number;\n\n  /**\n   * Fee.\n   */\n  fee: number;\n\n  /**\n   * Storage Fee.\n   */\n  storage_fee: number;\n\n  /**\n   * Other Fee.\n   */\n  other_fee: number;\n\n  /**\n   * Transaction Type.\n   */\n  transaction_type: string;\n\n  /**\n   * Compute Skip Reason.\n   */\n  compute_skip_reason?: string;\n\n  /**\n   * Compute Exit Code.\n   */\n  compute_exit_code?: Maybe<number>;\n\n  /**\n   * Compute Gas Used.\n   */\n  compute_gas_used?: Maybe<number>;\n\n  /**\n   * Compute Gas Limit.\n   */\n  compute_gas_limit?: Maybe<number>;\n\n  /**\n   * Compute Gas Credit.\n   */\n  compute_gas_credit?: Maybe<number>;\n\n  /**\n   * Compute Gas Fees.\n   */\n  compute_gas_fees?: Maybe<number>;\n\n  /**\n   * Compute Vm Steps.\n   */\n  compute_vm_steps?: Maybe<number>;\n\n  /**\n   * Action Result Code.\n   */\n  action_result_code?: Maybe<number>;\n\n  /**\n   * Action Total Fwd Fees.\n   */\n  action_total_fwd_fees?: Maybe<number>;\n\n  /**\n   * Action Total Action Fees.\n   */\n  action_total_action_fees?: Maybe<number>;\n\n  in_msg?: Maybe<MessageResponse>;\n\n  /**\n   * Out Msgs.\n   */\n  out_msgs?: Maybe<MessageResponse[]>;\n\n}\n\n\nexport class Transaction {\n\n  /**\n   * Account.\n   */\n  public account: string;\n\n  /**\n   * Lt.\n   */\n  public lt: number;\n\n  /**\n   * Hash.\n   */\n  public hash: string;\n\n  /**\n   * Utime.\n   */\n  public utime: Date;\n\n  /**\n   * Fee.\n   */\n  public fee: bigint;\n\n  /**\n   * Storage Fee.\n   */\n  public storageFee: bigint;\n\n  /**\n   * Other Fee.\n   */\n  public otherFee: bigint;\n\n  /**\n   * Transaction Type.\n   */\n  public transactionType: string;\n\n  /**\n   * Compute Skip Reason.\n   */\n  public computeSkipReason?: Maybe<string>;\n\n  /**\n   * Compute Exit Code.\n   */\n  public computeExitCode?: Maybe<number>;\n\n  /**\n   * Compute Gas Used.\n   */\n  public computeGasUsed?: MaybeBigInt;\n\n  /**\n   * Compute Gas Limit.\n   */\n  public computeGasLimit?: MaybeBigInt;\n\n  /**\n   * Compute Gas Credit.\n   */\n  public computeGasCredit?: MaybeBigInt;\n\n  /**\n   * Compute Gas Fees.\n   */\n  public computeGasFees?: MaybeBigInt;\n\n  /**\n   * Compute Vm Steps.\n   */\n  public computeVmSteps?: Maybe<number>;\n\n  /**\n   * Action Result Code.\n   */\n  public actionResultCode?: Maybe<number>;\n\n  /**\n   * Action Total Fwd Fees.\n   */\n  public actionTotalFwdFees?: MaybeBigInt;\n\n  /**\n   * Action Total Action Fees.\n   */\n  public actionTotalActionFees?: MaybeBigInt;\n\n  public inMsg?: Maybe<Message>;\n\n  /**\n   * Out Msgs.\n   */\n  public outMsgs?: Maybe<Message[]>;\n\n\n  constructor(response: TransactionResponse) {\n\n    this.account = response.account;\n    this.lt = response.lt;\n    this.hash = response.hash;\n    this.utime = new Date(response.utime * 1_000);\n    this.fee = BigInt(response.fee);\n    this.storageFee = BigInt(response.storage_fee);\n    this.otherFee = BigInt(response.other_fee);\n    this.transactionType = response.transaction_type;\n    this.computeSkipReason = response.compute_skip_reason;\n    this.computeExitCode = response.compute_exit_code;\n    this.computeGasUsed = maybeBigInt(response.compute_gas_used);\n    this.computeGasLimit = maybeBigInt(response.compute_gas_limit);\n    this.computeGasCredit = maybeBigInt(response.compute_gas_credit);\n    this.computeGasFees = maybeBigInt(response.compute_gas_fees);\n    this.computeVmSteps = response.compute_vm_steps;\n    this.actionResultCode = response.action_result_code;\n    this.actionTotalFwdFees = maybeBigInt(response.action_total_fwd_fees);\n    this.actionTotalActionFees = maybeBigInt(response.action_total_action_fees);\n\n    this.inMsg = (response.in_msg\n      ? new Message(response.in_msg)\n      : undefined\n    );\n\n    this.outMsgs = (response.out_msgs\n      ? response.out_msgs.map(\n          message => new Message(message)\n        )\n      : undefined\n    );\n\n  }\n\n}\n\n\nexport function parseTransactionResponse(\n  response: TransactionResponse\n\n): Transaction {\n\n  return new Transaction(response);\n\n}\n\nexport function parseTransactionsListResponse(\n  response: TransactionResponse[]\n\n): Transaction[] {\n\n  return response.map(\n    transaction => new Transaction(transaction)\n  );\n\n}\n", "\nimport type { RequestParams } from '../../ton-index-client/request-params';\nimport type { TonIndexClient } from '../../ton-index-client/ton-index-client.js';\nimport type { Maybe } from '../../types/maybe.js';\n\n\nexport interface MakeRequestArgs <\n  ParamsType extends RequestParams = RequestParams,\n  ResponseType = any,\n  ResultType = any\n> {\n\n  client: TonIndexClient;\n\n  url: string;\n\n  params: ParamsType;\n\n  /**\n   * Parameters serialization function. Optional.\n   */\n  serializeParams?: (\n    (params: ParamsType) => RequestParams\n  );\n\n  /**\n   * Response deserialization function.\n   */\n  deserializeResponse?: (\n    (response: ResponseType) => ResultType\n  );\n\n  options?: Maybe<ExtraRequestOptions>;\n\n}\n\nexport interface ExtraRequestOptions {\n\n  /**\n   * Request timeout in milliseconds.\n   */\n  timeout?: number;\n\n}\n\n\nexport async function makeRequest <\n  ParamsType extends RequestParams = RequestParams,\n  ResponseType = any,\n  ResultType = any\n\n> (args: MakeRequestArgs<\n  ParamsType,\n  ResponseType,\n  ResultType\n\n>): Promise<ResultType> {\n\n  const {\n    client,\n    url,\n    params,\n    serializeParams,\n    deserializeResponse,\n    options,\n\n  } = args;\n\n  const response = await client.request<ResponseType>({\n    params: (serializeParams\n      ? serializeParams(params)\n      : params\n    ),\n    url,\n    timeout: options?.timeout,\n  });\n\n  return (deserializeResponse\n    ? deserializeResponse(response)\n    : <ResultType> response\n  );\n\n}\n", "\nimport type { Maybe } from '../types/maybe.js';\n\n\nexport type AnyTime = (number | Date);\nexport type Timestamp = number;\n\nconst edgeTime = Math.pow(10, 10);\n\n\nexport function normalizeTimestamp(time: AnyTime): Timestamp {\n\n  if (time instanceof Date) {\n    return Math.floor(time.getTime() / 1_000);\n  }\n\n  // noinspection SuspiciousTypeOfGuard\n  if (typeof time === 'number') {\n\n    if (time > edgeTime) {\n      // Converting from millis to seconds\n      return (time / 1_000);\n\n    } else {\n      return time;\n\n    }\n\n  }\n\n  throw new Error(`Unknown timestamp format specified`);\n\n}\n\nexport function maybeNormalizeTimestamp(\n  time?: AnyTime\n\n): Maybe<Timestamp> {\n\n  if (!time && time !== 0) {\n    return undefined;\n  }\n\n  return normalizeTimestamp(time);\n\n}\n", "\nimport type { AnyTime } from '../common/timestamp.js';\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe.js';\nimport { ExtraRequestOptions, makeRequest } from './common/make-request.js';\nimport { maybeNormalizeTimestamp, normalizeTimestamp } from '../common/timestamp.js';\n\nimport type { GetActiveAccountsCountInPeriod as NS } from './get-active-accounts-count-in-period.js';\n\n\nexport namespace GetActiveAccountsCountInPeriod {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * UTC timestamp of period start.\n     */\n    startUtime: AnyTime;\n\n    /**\n     * UTC timestamp of period end. If not specified\n     * the current time is used.\n     */\n    endUtime?: Maybe<AnyTime>;\n\n  }\n\n  export interface Response {\n    count: number;\n  }\n\n  export interface Result {\n    count: number;\n  }\n\n}\n\n\n\n/**\n * Gets active accounts count in the specified time period.\n */\nexport async function getActiveAccountsCountInPeriod(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getActiveAccountsCountInPeriod',\n    params,\n    serializeParams: params => ({\n      ...params,\n      startUtime: normalizeTimestamp(params.startUtime),\n      endUtime: maybeNormalizeTimestamp(params.endUtime),\n    }),\n    deserializeResponse: response => ({\n      count: response.count,\n    }),\n    options,\n  });\n\n}\n", "\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { BlockResponse } from '../model/block.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe';\nimport { ExtraRequestOptions, makeRequest } from './common/make-request';\nimport { Block } from '../model/block.js';\n\nimport type { GetBlockByTransaction as NS } from './get-block-by-transaction.js';\n\n\nexport namespace GetBlockByTransaction {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * Transaction's hash.\n     */\n    txHash: string;\n\n  }\n\n  export type Response = BlockResponse;\n\n  export type Result = Block;\n\n}\n\n/**\n * Gets block by the specified transaction.\n */\nexport async function getBlockByTransaction(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getBlockByTransaction',\n    params,\n    deserializeResponse: response => new Block(response),\n    options,\n  });\n\n}\n", "\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { WorkchainType } from '../common/workchain.js';\nimport type { BlockResponse } from '../model/block.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe.js';\nimport type { SortDirection, SortDirectionType } from '../common/sort.js';\nimport { ExtraRequestOptions, makeRequest } from './common/make-request';\nimport { Block, parseBlocksListResponse } from '../model/block.js';\nimport { AnyTime, maybeNormalizeTimestamp } from '../common/timestamp.js';\n\nimport type { GetBlocksByUnixTime as NS } from './get-blocks-by-unix-time.js';\n\n\nexport namespace GetBlocksByUnixTime {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * UTC timestamp to start searching blocks.\n     */\n    startUtime?: Maybe<AnyTime>;\n\n    /**\n     * UTC timestamp to stop searching blocks.\n     * If not specified the latest blocks are returned.\n     */\n    endUtime?: Maybe<AnyTime>;\n\n    /**\n     * Filter by workchain. Use the {@link Workchain} helper\n     * to specify the workchain ID.\n     */\n    workchain?: Maybe<WorkchainType>;\n\n    /**\n     * Filter by shard prefix.\n     */\n    shard?: Maybe<string>;\n\n    /**\n     * Number of blocks to return, maximum limit is 1000.\n     *\n     * @defaultValue 20\n     */\n    limit?: Maybe<number>;\n\n    /**\n     * Number of rows to omit before the beginning\n     * of the result set.\n     *\n     * @defaultValue 0\n     */\n    offset?: Maybe<number>;\n\n    /**\n     * Sort direction. Use {@link SortDirection}\n     * to specify the direction.\n     *\n     * @defaultValue `SortDirection.DESC`\n     */\n    sort?: Maybe<SortDirectionType>;\n\n  }\n\n  export type Response = BlockResponse[];\n\n  export type Result = Block[];\n\n}\n\n\n/**\n * Gets blockchain blocks according to the various filter\n * criteria.\n */\nexport async function getBlocksByUnixTime(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getBlocksByUnixTime',\n    params,\n    serializeParams: params => ({\n      ...params,\n      startUtime: maybeNormalizeTimestamp(params.startUtime),\n      endUtime: maybeNormalizeTimestamp(params.endUtime),\n    }),\n    deserializeResponse: parseBlocksListResponse,\n    options,\n  });\n\n}\n", "\nimport type { AnyTime } from '../common/timestamp.js';\nimport type { TransactionResponse } from '../model/transaction.js';\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { WorkchainType } from '../common/workchain.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe.js';\nimport { ExtraRequestOptions, makeRequest } from './common/make-request';\nimport { maybeNormalizeTimestamp } from '../common/timestamp.js';\nimport { parseTransactionsListResponse, Transaction } from '../model/transaction.js';\n\nimport type { GetChainLastTransactions as NS } from './get-chain-last-transactions.js';\n\n\nexport namespace GetChainLastTransactions {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * Filter by workchain. Use the {@link Workchain} helper\n     * to specify the workchain ID.\n     */\n    workchain: WorkchainType;\n\n    /**\n     * UTC timestamp to start searching transactions.\n     */\n    startUtime?: Maybe<AnyTime>;\n\n    /**\n     * UTC timestamp to stop searching transactions.\n     * If not specified, the latest transactions are returned.\n     */\n    endUtime?: Maybe<AnyTime>;\n\n    /**\n     * Number of blocks to return, maximum limit is 1000.\n     *\n     * @defaultValue `20`\n     */\n    limit?: Maybe<number>;\n\n    /**\n     * Number of rows to omit before the beginning\n     * of the result set.\n     *\n     * @defaultValue `0`\n     */\n    offset?: Maybe<number>;\n\n    /**\n     * Whether to return full message body or not.\n     *\n     * @defaultValue `false`\n     */\n    includeMsgBody?: Maybe<boolean>;\n\n  }\n\n  export type Response = TransactionResponse[];\n\n  export type Result = Transaction[];\n\n}\n\n\n/**\n * Gets the latest transactions of the specified workchain.\n * Response is sorted descending by transaction's timestamp.\n */\nexport async function getChainLastTransactions(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getChainLastTransactions',\n    params,\n    serializeParams: params => ({\n      ...params,\n      startUtime: maybeNormalizeTimestamp(params.startUtime),\n      endUtime: maybeNormalizeTimestamp(params.endUtime),\n    }),\n    deserializeResponse: parseTransactionsListResponse,\n    options,\n  });\n\n}\n", "\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { TransactionResponse } from '../model/transaction';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe';\nimport type { Transaction } from '../model/transaction.js';\nimport { ExtraRequestOptions, makeRequest } from './common/make-request';\nimport { parseTransactionResponse } from '../model/transaction.js';\n\nimport type { GetDestinationTransactionByMessage as NS } from './get-destination-transaction-by-message.js';\n\n\nexport namespace GetDestinationTransactionByMessage {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * Sender address.\n     */\n    source: string;\n\n    /**\n     * Receiver address.\n     */\n    destination: string;\n\n    /**\n     * Creation logical time of the message.\n     */\n    msgLt: number;\n\n  }\n\n  export type Response = TransactionResponse;\n\n  export type Result = Transaction;\n\n}\n\n\n/**\n * Gets transaction of the destination address by outgoing\n * message on source address.\n */\nexport async function getDestinationTransactionByMessage(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getDestinationTransactionByMessage',\n    params,\n    deserializeResponse: parseTransactionResponse,\n    options,\n  });\n\n}\n", "\nconst hexHashRE = /^[a-fA-F0-9]{64}$/;\n\n\nexport function serializeHash(hash: string): string {\n\n  // Converting HEX hashes to the Base64 representation,\n  // because API expects them in this format.\n  if (hexHashRE.test(hash)) {\n\n    if (typeof Buffer !== 'undefined' && Buffer?.from) {\n      // Node.js\n      return Buffer.from(hash, 'hex').toString('base64');\n\n    } else if (typeof btoa === 'function') {\n      // Browser\n      let base64 = '';\n      for (let i = 0; i < hash.length; i++) {\n        base64 += !(i - 1 & 1) ? String.fromCharCode(\n          parseInt(hash.substring(i - 1, i + 1), 16)\n        ) : ''\n      }\n      return btoa(base64);\n\n    } else {\n      // Logging the warning and falling back to returning\n      // hash in the HEX format.\n      console.warn(\n        `Can't convert HEX hash to Base64, ` +\n        `environment not supported`\n      );\n\n    }\n\n  }\n\n  return hash;\n\n}\n", "\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { MessageResponse } from '../model/message.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe.js';\nimport { ExtraRequestOptions, makeRequest } from './common/make-request';\nimport { Message, parseMessageResponse } from '../model/message.js';\nimport { serializeHash } from '../common/hash.js';\n\nimport type { GetInMessageByTxID as NS } from './get-in-message-by-tx-id.js';\n\n\nexport namespace GetInMessageByTxID {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * Logical time of transaction.\n     */\n    txLt: number;\n\n    /**\n     * Transaction's hash (in HEX or Base64 format).\n     */\n    txHash: string;\n\n    /**\n     * Whether to return full message body or not.\n     *\n     * @defaultValue `false`\n     */\n    includeMsgBody?: Maybe<boolean>;\n\n  }\n\n  export type Response = MessageResponse;\n\n  export type Result = Message;\n\n}\n\n\n/**\n * Gets incoming message by the specified transaction.\n */\nexport async function getInMessageByTxID(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getInMessageByTxID',\n    params,\n    deserializeResponse: parseMessageResponse,\n    serializeParams: params => ({\n      ...params,\n      txHash: serializeHash(params.txHash),\n    }),\n    options,\n  });\n\n}\n", "\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { MessageResponse } from '../model/message.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe.js';\nimport type { Message } from '../model/message.js';\nimport { ExtraRequestOptions, makeRequest } from './common/make-request';\nimport { parseMessageListResponse } from '../model/message.js';\nimport { serializeHash } from '../common/hash.js';\n\nimport type { GetMessagesByHash as NS } from './get-messages-by-hash.js';\n\n\nexport namespace GetMessagesByHash {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * Message hash (in HEX or Base64 format).\n     */\n    msgHash: string;\n\n    /**\n     * Whether to return full message body or not.\n     *\n     * @defaultValue `false`\n     */\n    includeMsgBody?: Maybe<boolean>;\n\n  }\n\n  export type Response = MessageResponse[];\n\n  export type Result = Message[];\n\n}\n\n\n/**\n * Gets messages by the specified hash.\n */\nexport async function getMessagesByHash(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getMessageByHash',\n    params,\n    deserializeResponse: parseMessageListResponse,\n    serializeParams: params => ({\n      ...params,\n      msgHash: serializeHash(params.msgHash),\n    }),\n    options,\n  });\n\n}\n", "\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { MessageResponse } from '../model/message.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe.js';\nimport type { Message } from '../model/message.js';\nimport { ExtraRequestOptions, makeRequest } from './common/make-request';\nimport { parseMessageListResponse } from '../model/message.js';\nimport { serializeHash } from '../common/hash.js';\n\nimport type { GetOutMessagesByTxID as NS } from './get-out-messages-by-tx-id.js';\n\n\nexport namespace GetOutMessagesByTxID {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * Logical time of transaction.\n     */\n    txLt: number;\n\n    /**\n     * Transaction's hash (in HEX or Base64 format).\n     */\n    txHash: string;\n\n    /**\n     * Whether to return full message body or not.\n     *\n     * @defaultValue `false`\n     */\n    includeMsgBody?: Maybe<boolean>;\n\n  }\n\n  export type Response = MessageResponse[];\n\n  export type Result = Message[];\n\n}\n\n\n/**\n * Gets outgoing messages for the specified transaction.\n */\nexport async function getOutMessagesByTxID(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getOutMessagesByTxID',\n    params,\n    deserializeResponse: parseMessageListResponse,\n    serializeParams: params => ({\n      ...params,\n      txHash: serializeHash(params.txHash),\n    }),\n    options,\n  });\n\n}\n", "\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { TransactionResponse } from '../model/transaction.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe';\nimport type { ExtraRequestOptions } from './common/make-request';\nimport type { Transaction } from '../model/transaction.js';\nimport { makeRequest } from './common/make-request';\nimport { parseTransactionResponse } from '../model/transaction.js';\n\nimport type { GetSourceTransactionByMessage as NS } from './get-source-transaction-by-message.js';\n\n\nexport namespace GetSourceTransactionByMessage {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * Source address.\n     */\n    source: string;\n\n    /**\n     * Destination address.\n     */\n    destination: string;\n\n    /**\n     * Creation logical time of the message.\n     */\n    msgLt: number;\n\n  }\n\n  export type Response = TransactionResponse;\n\n  export type Result = Transaction;\n\n}\n\n\n/**\n * Gets transaction of source address by incoming message\n * on the destination address.\n */\nexport async function getSourceTransactionByMessage(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getSourceTransactionByMessage',\n    params,\n    deserializeResponse: parseTransactionResponse,\n    options,\n  });\n\n}\n", "\nimport type { TransactionResponse } from '../model/transaction.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe.js';\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { Transaction } from '../model/transaction.js';\nimport type { ExtraRequestOptions } from './common/make-request';\nimport { makeRequest } from './common/make-request';\nimport { parseTransactionResponse } from '../model/transaction.js';\nimport { serializeHash } from '../common/hash.js';\n\nimport type { GetTransactionByHash as NS } from './get-transaction-by-hash.js';\n\n\nexport namespace GetTransactionByHash {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * Transaction's hash (in HEX or Base64 format).\n     */\n    txHash: string;\n\n    /**\n     * Whether to return full message body or not.\n     *\n     * @defaultValue `false`\n     */\n    includeMsgBody?: Maybe<boolean>;\n\n  }\n\n  export type Response = TransactionResponse[];\n\n  export type Result = Maybe<Transaction>;\n\n}\n\n\n/**\n * Gets transaction by the specified hash.\n */\nexport async function getTransactionByHash(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getTransactionByHash',\n    params,\n    serializeParams: params => ({\n      ...params,\n      txHash: serializeHash(params.txHash),\n    }),\n    deserializeResponse: response => {\n\n      /**\n       * For some reason server returns a list of\n       * transactions as a response, however, in practice\n       * this should be 0 or 1 situation.\n       *\n       * Correcting this behavior.\n       */\n\n      if (response.length > 1) {\n        throw new Error(\n          'Multiple transactions returned with the same hash'\n        );\n      }\n\n      return (response[0]\n        ? parseTransactionResponse(response[0])\n        : undefined\n      );\n\n    },\n    options,\n  });\n\n}\n", "\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { TransactionResponse } from '../model/transaction.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe.js';\nimport type { Transaction } from '../model/transaction.js';\nimport type { ExtraRequestOptions } from './common/make-request';\nimport { makeRequest } from './common/make-request';\nimport { parseTransactionsListResponse } from '../model/transaction.js';\nimport { serializeHash } from '../common/hash.js';\n\nimport type { GetTransactionsByInMessageHash as NS } from './get-transactions-by-in-message-hash.js';\n\n\nexport namespace GetTransactionsByInMessageHash {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * Incoming message hash (in HEX or Base64 format).\n     */\n    msgHash: string;\n\n    /**\n     * Whether to include message body in the response.\n     *\n     * @defaultValue `false`\n     */\n    includeMsgBody?: Maybe<boolean>;\n\n  }\n\n  export type Response = TransactionResponse[];\n\n  export type Result = Transaction[];\n\n}\n\n\n/**\n * Gets transactions by the specified incoming message hash.\n */\nexport async function getTransactionsByInMessageHash(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getTransactionByInMessageHash',\n    params,\n    deserializeResponse: parseTransactionsListResponse,\n    serializeParams: params => ({\n      ...params,\n      msgHash: serializeHash(params.msgHash),\n    }),\n    options,\n  });\n\n}\n", "\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { TransactionResponse } from '../model/transaction.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe.js';\nimport type { SortDirection, SortDirectionType } from '../common/sort.js';\nimport type { Transaction } from '../model/transaction.js';\nimport type { AnyTime } from '../common/timestamp.js';\nimport type { ExtraRequestOptions } from './common/make-request';\nimport { makeRequest } from './common/make-request';\nimport { parseTransactionsListResponse } from '../model/transaction.js';\nimport { maybeNormalizeTimestamp } from '../common/timestamp.js';\n\nimport type { GetTransactionsByAddress as NS } from './get-transactions-by-address.js';\n\n\nexport namespace GetTransactionsByAddress {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * The address to get transactions.\n     * Can be sent in any form.\n     */\n    address: string;\n\n    /**\n     * UTC timestamp to start searching transactions.\n     */\n    startUtime?: Maybe<AnyTime>;\n\n    /**\n     * UTC timestamp to stop searching transactions.\n     * If not specified the latest transactions are returned.\n     */\n    endUtime?: Maybe<AnyTime>;\n\n    /**\n     * Number of blocks to return, maximum limit is 1000.\n     *\n     * @defaultValue `20`\n     */\n    limit?: Maybe<number>;\n\n    /**\n     * Number of rows to omit before the beginning\n     * of the result set.\n     *\n     * @defaultValue `0`\n     */\n    offset?: Maybe<number>;\n\n    /**\n     * Sort direction, use {@link SortDirection}\n     * to specify the direction.\n     *\n     * @defaultValue `SortDirection.DESC`\n     */\n    sort?: Maybe<SortDirectionType>;\n\n    /**\n     * Whether to return full message body or not.\n     *\n     * @defaultValue `false`\n     */\n    includeMsgBody?: Maybe<boolean>;\n\n  }\n\n  export type Response = TransactionResponse[];\n\n  export type Result = Transaction[];\n\n}\n\n\n/**\n * Gets transactions for the specified account address.\n */\nexport async function getTransactionsByAddress(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getTransactionsByAddress',\n    params,\n    serializeParams: params => ({\n      ...params,\n      startUtime: maybeNormalizeTimestamp(params.startUtime),\n      endUtime: maybeNormalizeTimestamp(params.endUtime),\n    }),\n    deserializeResponse: parseTransactionsListResponse,\n    options,\n  });\n\n}\n", "\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { TransactionResponse } from '../model/transaction.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe.js';\nimport type { Transaction } from '../model/transaction.js';\nimport type { ExtraRequestOptions } from './common/make-request';\nimport { makeRequest } from './common/make-request';\nimport { parseTransactionsListResponse } from '../model/transaction.js';\n\nimport type { GetTransactionsByMasterchainSeqno as NS } from './get-transactions-by-masterchain-seqno.js';\n\n\nexport namespace GetTransactionsByMasterchainSeqno {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * Masterchain block sequence number.\n     */\n    seqno: number;\n\n    /**\n     * Whether to include message body in the response.\n     *\n     * @defaultValue `false`\n     */\n    includeMsgBody?: Maybe<boolean>;\n\n  }\n\n  export type Response = TransactionResponse[];\n\n  export type Result = Transaction[];\n\n}\n\n\n/**\n * Gets transactions by masterchain seqno across all\n * workchains and shardchains.\n */\nexport async function getTransactionsByMasterchainSeqno(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getTransactionsByMasterchainSeqno',\n    params,\n    deserializeResponse: parseTransactionsListResponse,\n    options,\n  });\n\n}\n", "\nimport type { TransactionResponse } from '../model/transaction.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe.js';\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { WorkchainType } from '../common/workchain.js';\nimport { ExtraRequestOptions, makeRequest } from './common/make-request';\nimport { parseTransactionsListResponse, Transaction } from '../model/transaction.js';\n\nimport type { GetTransactionsInBlock as NS } from './get-transactions-in-block.js';\n\n\nexport namespace GetTransactionsInBlock {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * Block workchain. Use the {@link Workchain} helper\n     * to specify the workchain ID.\n     */\n    workchain: WorkchainType;\n\n    /**\n     * Block's shard prefix.\n     */\n    shard: string;\n\n    /**\n     * Block's sequence number.\n     */\n    seqno: number;\n\n    /**\n     * Whether to return full message body or not.\n     *\n     * @defaultValue `false`\n     */\n    includeMsgBody?: Maybe<boolean>;\n\n  }\n\n  export type Response = TransactionResponse[];\n\n  export type Result = Transaction[];\n\n}\n\n\n/**\n * Gets transactions of the specified block.\n */\nexport async function getTransactionsInBlock(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'getTransactionsInBlock',\n    params,\n    deserializeResponse: parseTransactionsListResponse,\n    options,\n  });\n\n}\n", "\nimport type { RequestParams } from '../ton-index-client/request-params';\nimport type { WorkchainType } from '../common/workchain.js';\nimport type { BlockResponse } from '../model/block.js';\nimport type { TonIndexClient } from '../ton-index-client/ton-index-client';\nimport type { Maybe } from '../types/maybe';\nimport type { Block } from '../model/block.js';\nimport type { ExtraRequestOptions } from './common/make-request';\nimport { makeRequest } from './common/make-request';\nimport { parseBlockResponse } from '../model/block.js';\n\nimport type { LookupMasterchainBlock as NS } from './lookup-masterchain-block.js';\n\n\nexport namespace LookupMasterchainBlock {\n\n  export interface Params extends RequestParams {\n\n    /**\n     * Workchain ID. Use the {@link Workchain} helper\n     * to specify the workchain ID.\n     */\n    workchain: WorkchainType;\n\n    /**\n     * Block's shard prefix.\n     */\n    shard: string;\n\n    /**\n     * Block's sequence number.\n     */\n    seqno: number;\n\n  }\n\n  export type Response = BlockResponse;\n\n  export type Result = Block;\n\n}\n\n\n/**\n * Gets corresponding masterchain block by a shardchain one.\n */\nexport async function lookupMasterchainBlock(\n  client: TonIndexClient,\n  params: NS.Params,\n  options?: Maybe<ExtraRequestOptions>\n\n): Promise<NS.Result> {\n\n  return makeRequest<NS.Params, NS.Response, NS.Result>({\n    client,\n    url: 'lookupMasterchainBlock',\n    params,\n    deserializeResponse: parseBlockResponse,\n    options,\n  });\n\n}\n", "\nimport type { Values } from '../types/values.js';\n\n\nexport const Workchain = {\n  Master: -1,\n  Basic: 0,\n\n} as const;\n\nexport type WorkchainType = (\n  | Values<typeof Workchain>\n);\n", "\nimport type { Values } from '../types/values.js';\n\n\nexport const SortDirection = {\n  ASC: 'asc',\n  DESC: 'desc',\n\n} as const;\n\nexport type SortDirectionType = Values<typeof SortDirection>;\n"],
  "mappings": "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",
  "names": ["snakeCase", "params", "params", "params", "params", "params", "params", "params", "params", "params"]
}
